package memory

import (
	"context"
	"errors"
	"sync"

	"{{ .Module }}/internal/core/entity"
)

type UserRepo struct {
	mu sync.RWMutex
	m  map[string]*entity.User
}

func NewUserRepo() *UserRepo {
	return &UserRepo{m: make(map[string]*entity.User)}
}

func (r *UserRepo) Save(_ context.Context, u *entity.User) error {
	r.mu.Lock()
	defer r.mu.Unlock()
	r.m[u.ID] = u
	return nil
}

func (r *UserRepo) FindByID(_ context.Context, id string) (*entity.User, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()
	if u, ok := r.m[id]; ok {
		return u, nil
	}
	return nil, errors.New("not found")
}

func (r *UserRepo) List(_ context.Context, limit, offset int) ([]*entity.User, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()
	out := make([]*entity.User, 0, len(r.m))
	for _, u := range r.m {
		out = append(out, u)
	}
	// naive paging
	if offset > len(out) { return []*entity.User{}, nil }
	end := offset + limit
	if limit == 0 || end > len(out) { end = len(out) }
	return out[offset:end], nil
}
