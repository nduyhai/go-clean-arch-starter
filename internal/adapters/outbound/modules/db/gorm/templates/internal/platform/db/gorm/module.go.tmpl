package gormdb

import (
	"strings"
	"time"

	"github.com/spf13/viper"
	"go.uber.org/fx"
	"gorm.io/driver/mysql"
	"gorm.io/driver/postgres"
	"gorm.io/driver/sqlite"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

// Module provides *gorm.DB via Fx. It reads configuration from Viper with ENV overrides.
//
// Config layout (also see config/defaults.yml):
// gorm:
//   driver: "postgres"  # postgres | mysql | sqlite
//   dsn: "postgres://user:pass@localhost:5432/app?sslmode=disable"
//   log_level: "warn"   # silent|error|warn|info
//   max_open_conns: 25
//   max_idle_conns: 5
//   conn_max_lifetime: 30m
//
// ENV overrides supported by Viper via GORM_DRIVER, GORM_DSN, etc., because viper is configured
// to map dots to underscores. We also set the replacer here for safety.
func Module() fx.Option {
	return fx.Provide(func() (*gorm.DB, error) {
		v := viper.New()
		v.SetConfigName("config")
		v.SetConfigType("yaml")
		v.AddConfigPath("config")
		_ = v.ReadInConfig()
		v.AutomaticEnv()
		v.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))

		driver := v.GetString("gorm.driver")
		if driver == "" {
			driver = "sqlite"
		}
		dsn := v.GetString("gorm.dsn")

		// Logger level
		lvlStr := strings.ToLower(v.GetString("gorm.log_level"))
		var lvl logger.LogLevel
		switch lvlStr {
		case "silent":
			lvl = logger.Silent
		case "error":
			lvl = logger.Error
		case "info":
			lvl = logger.Info
		default:
			lvl = logger.Warn
		}
		gcfg := &gorm.Config{Logger: logger.Default.LogMode(lvl)}

		var (
			db  *gorm.DB
			err error
		)
		switch driver {
		case "postgres", "pg", "postgre":
			db, err = gorm.Open(postgres.Open(dsn), gcfg)
		case "mysql":
			db, err = gorm.Open(mysql.Open(dsn), gcfg)
		case "sqlite":
			fallthrough
		default:
			if dsn == "" {
				dsn = "file:app.db?_pragma=busy_timeout=5000&_pragma=journal_mode=WAL"
			}
			db, err = gorm.Open(sqlite.Open(dsn), gcfg)
		}
		if err != nil {
			return nil, err
		}

		// Connection pool settings
		sqlDB, err := db.DB()
		if err == nil {
			if n := v.GetInt("gorm.max_open_conns"); n > 0 {
				sqlDB.SetMaxOpenConns(n)
			}
			if n := v.GetInt("gorm.max_idle_conns"); n > 0 {
				sqlDB.SetMaxIdleConns(n)
			}
			if s := v.GetString("gorm.conn_max_lifetime"); s != "" {
				if d, perr := time.ParseDuration(s); perr == nil {
					sqlDB.SetConnMaxLifetime(d)
				}
			}
		}
		return db, nil
	})
}
